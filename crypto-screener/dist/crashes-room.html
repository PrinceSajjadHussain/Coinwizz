<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE GREAT CRASHES ROOM | CryptoSpaces</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;500&family=Cinzel:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --stone-dark: #1a1a1f;
            --stone-darker: #0d0d10;
            --steel-gray: #2d2d35;
            --blood-red: #8b1a1a;
            --danger-red: #dc2626;
            --dust: rgba(180, 170, 160, 0.3);
            --text: #c4c4c8;
            --text-muted: rgba(196, 196, 200, 0.5);
            --crack: rgba(139, 26, 26, 0.6);
        }

        /* Unified Header */
        .unified-header {
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 1000;
            background: linear-gradient(180deg, rgba(13, 13, 16, 0.98) 0%, rgba(13, 13, 16, 0.7) 100%);
            padding: 12px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(139, 26, 26, 0.3);
        }
        .unified-left { display: flex; align-items: center; gap: 20px; }
        .unified-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            background: linear-gradient(90deg, #8b1a1a, #dc2626);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
            letter-spacing: 2px;
        }
        .unified-nav { display: flex; gap: 10px; }
        .unified-nav-link {
            color: var(--text);
            text-decoration: none;
            font-size: 0.6rem;
            font-family: 'Orbitron', sans-serif;
            padding: 6px 12px;
            border: 1px solid rgba(139, 26, 26, 0.3);
            border-radius: 5px;
            transition: all 0.2s;
            background: rgba(139, 26, 26, 0.05);
        }
        .unified-nav-link:hover {
            background: rgba(139, 26, 26, 0.15);
            box-shadow: 0 0 15px rgba(139, 26, 26, 0.2);
        }
        .unified-utils { display: flex; gap: 10px; }
        .unified-btn {
            background: rgba(139, 26, 26, 0.1);
            border: 1px solid rgba(139, 26, 26, 0.3);
            color: var(--text);
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            transition: all 0.2s;
            text-decoration: none;
        }
        .unified-btn:hover {
            background: rgba(139, 26, 26, 0.2);
        }

        body {
            font-family: 'Cinzel', serif;
            background: var(--stone-darker);
            min-height: 100vh;
            color: var(--text);
            overflow: hidden;
        }

        /* The Hall */
        .crashes-hall {
            position: fixed;
            top: 55px; left: 0; right: 0; bottom: 0;
            background: 
                linear-gradient(180deg, rgba(13,13,16,0.9) 0%, transparent 30%),
                linear-gradient(0deg, rgba(13,13,16,0.95) 0%, transparent 40%),
                radial-gradient(ellipse at 50% 0%, rgba(139, 26, 26, 0.03) 0%, transparent 50%),
                linear-gradient(180deg, var(--stone-dark) 0%, var(--stone-darker) 100%);
            overflow: hidden;
        }

        /* Pillars */
        .pillars {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        .pillar {
            position: absolute;
            width: 60px;
            bottom: 0;
            background: linear-gradient(90deg, #252528 0%, #3a3a40 50%, #252528 100%);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .pillar::before {
            content: '';
            position: absolute;
            top: 0; left: -10px; right: -10px;
            height: 30px;
            background: linear-gradient(180deg, #3a3a40, #252528);
            border-radius: 5px 5px 0 0;
        }
        .pillar.cracked::after {
            content: '';
            position: absolute;
            top: 30%;
            left: 50%;
            width: 3px;
            height: 40%;
            background: var(--crack);
            transform: translateX(-50%) rotate(5deg);
            box-shadow: 0 0 10px var(--blood-red);
            animation: crack-glow 2s ease-in-out infinite alternate;
        }
        @keyframes crack-glow {
            from { opacity: 0.5; box-shadow: 0 0 5px var(--blood-red); }
            to { opacity: 1; box-shadow: 0 0 15px var(--blood-red); }
        }

        /* Dust particles */
        .dust-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .dust {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--dust);
            border-radius: 50%;
            animation: dust-fall 8s linear infinite;
        }
        @keyframes dust-fall {
            0% { transform: translateY(-20px) translateX(0); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.4; }
            100% { transform: translateY(100vh) translateX(30px); opacity: 0; }
        }

        /* Room title */
        .room-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
        }
        .room-title h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.6rem;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--blood-red);
            text-shadow: 0 0 30px rgba(139, 26, 26, 0.4);
        }
        .room-title .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.5rem;
            color: var(--text-muted);
            letter-spacing: 3px;
            margin-top: 5px;
        }

        /* Floor with cracks */
        .floor {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            background: 
                linear-gradient(180deg, transparent 0%, rgba(26, 26, 31, 0.8) 30%, #1a1a1f 100%);
            perspective: 800px;
        }
        .floor-tiles {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: 
                repeating-linear-gradient(90deg, transparent 0px, transparent 98px, rgba(60,60,70,0.3) 98px, rgba(60,60,70,0.3) 100px),
                repeating-linear-gradient(0deg, transparent 0px, transparent 98px, rgba(60,60,70,0.3) 98px, rgba(60,60,70,0.3) 100px);
            transform: rotateX(60deg);
            transform-origin: bottom center;
        }
        .floor-crack {
            position: absolute;
            bottom: 20px;
            width: 4px;
            height: 80px;
            background: linear-gradient(180deg, transparent, var(--crack), var(--blood-red), var(--crack), transparent);
            transform: rotate(var(--rotation, 0deg));
            opacity: 0;
            transition: opacity 1s ease;
            filter: blur(1px);
            box-shadow: 0 0 15px var(--blood-red);
        }
        .floor-crack.visible {
            opacity: 1;
        }

        /* Coins arena */
        .coins-arena {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 1000px;
            height: calc(100% - 250px);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 30px;
            padding: 20px;
        }

        /* Individual coin */
        .crash-coin {
            position: relative;
            width: 100px;
            height: 100px;
            cursor: pointer;
            transition: all 0.5s ease;
        }
        .crash-coin.falling {
            animation: coin-fall 3s ease-in forwards;
        }
        @keyframes coin-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            20% { transform: translateY(20px) rotate(5deg); }
            100% { transform: translateY(400px) rotate(45deg); opacity: 0; }
        }
        .crash-coin.shaking {
            animation: coin-shake 0.3s ease-in-out infinite;
        }
        @keyframes coin-shake {
            0%, 100% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-2px) translateY(1px); }
            75% { transform: translateX(2px) translateY(-1px); }
        }
        .crash-coin.sinking {
            animation: coin-sink 4s ease-in-out infinite;
        }
        @keyframes coin-sink {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(15px); }
        }

        /* Coin body */
        .coin-body {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4a4a52 0%, #2a2a30 50%, #1a1a1f 100%);
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.6),
                inset 0 2px 10px rgba(255,255,255,0.05),
                inset 0 -2px 10px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            position: relative;
            border: 2px solid rgba(100,100,110,0.3);
        }
        .coin-body img {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: contain;
            filter: grayscale(30%) brightness(0.9);
        }
        .coin-body::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            width: 20px;
            height: 10px;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), transparent);
            border-radius: 50%;
        }

        /* Coin info */
        .coin-data {
            text-align: center;
            margin-top: 8px;
            font-family: 'JetBrains Mono', monospace;
        }
        .coin-symbol {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text);
            letter-spacing: 1px;
        }
        .coin-change {
            font-size: 0.6rem;
            margin-top: 2px;
        }
        .coin-change.negative {
            color: var(--danger-red);
        }
        .coin-change.positive {
            color: #22c55e;
        }

        /* Impact crater */
        .crater {
            position: absolute;
            bottom: 30px;
            width: 60px;
            height: 20px;
            background: radial-gradient(ellipse, rgba(139,26,26,0.4) 0%, transparent 70%);
            border-radius: 50%;
            opacity: 0;
            transform: scale(0);
            transition: all 0.5s ease;
        }
        .crater.active {
            opacity: 1;
            transform: scale(1);
            animation: crater-pulse 2s ease-in-out infinite;
        }
        @keyframes crater-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(139,26,26,0.3); }
            50% { box-shadow: 0 0 40px rgba(139,26,26,0.5); }
        }

        /* Status panels */
        .status-panel {
            position: absolute;
            top: 90px;
            width: 180px;
            background: rgba(26, 26, 31, 0.85);
            border: 1px solid rgba(139, 26, 26, 0.2);
            border-radius: 6px;
            padding: 12px;
            backdrop-filter: blur(10px);
        }
        .status-panel.left { left: 20px; }
        .status-panel.right { right: 20px; }
        .panel-title {
            font-family: 'Cinzel', serif;
            font-size: 0.55rem;
            color: var(--blood-red);
            letter-spacing: 2px;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(139, 26, 26, 0.2);
        }
        .panel-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.5rem;
        }
        .panel-label { color: var(--text-muted); }
        .panel-value { 
            font-family: 'JetBrains Mono', monospace;
            color: var(--text);
        }
        .panel-value.danger { color: var(--danger-red); }
        .panel-value.warning { color: #f59e0b; }

        /* Fear gauge */
        .fear-gauge {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(139, 26, 26, 0.2);
        }
        .fear-label {
            font-size: 0.45rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        .fear-bar {
            height: 8px;
            background: linear-gradient(90deg, #22c55e 0%, #f59e0b 50%, #dc2626 100%);
            border-radius: 4px;
            position: relative;
        }
        .fear-indicator {
            position: absolute;
            top: -3px;
            width: 4px;
            height: 14px;
            background: white;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
            transition: left 0.5s ease;
        }
        .fear-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            text-align: center;
            margin-top: 5px;
        }

        /* Event feed */
        .event-feed {
            max-height: 150px;
            overflow-y: auto;
        }
        .event-item {
            font-size: 0.45rem;
            padding: 4px 0;
            border-bottom: 1px solid rgba(139, 26, 26, 0.1);
            color: var(--text-muted);
        }
        .event-item .time {
            color: var(--blood-red);
            margin-right: 5px;
        }

        /* Ambient rumble indicator */
        .rumble-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(26, 26, 31, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid rgba(139, 26, 26, 0.2);
        }
        .rumble-bars {
            display: flex;
            gap: 3px;
            align-items: flex-end;
            height: 20px;
        }
        .rumble-bar {
            width: 4px;
            background: var(--blood-red);
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        .rumble-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.5rem;
            color: var(--text-muted);
            letter-spacing: 1px;
        }

        /* Footer */
        .footer-disclaimer {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.4rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-align: center;
        }

        /* Sound Controls */
        .sound-controls {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(26, 26, 31, 0.9);
            border: 1px solid rgba(139, 26, 26, 0.3);
            border-radius: 8px;
            padding: 12px 15px;
            backdrop-filter: blur(10px);
            z-index: 500;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 140px;
        }
        .sound-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.5rem;
            color: var(--text);
        }
        .sound-toggle-btn {
            width: 40px;
            height: 20px;
            background: rgba(139, 26, 26, 0.3);
            border-radius: 10px;
            border: none;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        .sound-toggle-btn.active {
            background: var(--blood-red);
        }
        .sound-toggle-btn::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: all 0.3s;
        }
        .sound-toggle-btn.active::after {
            left: 22px;
        }
        .sound-intensity {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .intensity-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.45rem;
            color: var(--text-muted);
            letter-spacing: 1px;
        }
        .intensity-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(139, 26, 26, 0.3);
            border-radius: 2px;
            outline: none;
        }
        .intensity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--blood-red);
            border-radius: 50%;
            cursor: pointer;
        }
        .sound-hint {
            font-size: 0.4rem;
            color: var(--text-muted);
            text-align: center;
            font-style: italic;
        }

        /* Coin Hover Panel */
        .coin-hover-panel {
            position: fixed;
            z-index: 600;
            background: rgba(26, 26, 31, 0.92);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 26, 26, 0.4);
            border-radius: 10px;
            padding: 16px 20px;
            min-width: 220px;
            max-width: 280px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(139, 26, 26, 0.15);
        }
        .coin-hover-panel.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .coin-hover-panel .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(139, 26, 26, 0.25);
        }
        .coin-hover-panel .panel-header img {
            width: 36px;
            height: 36px;
            border-radius: 50%;
        }
        .coin-hover-panel .panel-header .coin-name {
            font-family: 'Cinzel', serif;
            font-size: 0.85rem;
            color: var(--text);
            font-weight: 600;
        }
        .coin-hover-panel .panel-header .coin-sym {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            color: var(--text-muted);
            letter-spacing: 1px;
        }
        .coin-hover-panel .data-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
        }
        .coin-hover-panel .data-label {
            color: var(--text-muted);
        }
        .coin-hover-panel .data-value {
            color: var(--text);
            font-weight: 500;
        }
        .coin-hover-panel .data-value.negative { color: var(--danger-red); }
        .coin-hover-panel .data-value.positive { color: #22c55e; }
        .coin-hover-panel .status-badge {
            display: inline-block;
            margin-top: 10px;
            padding: 4px 10px;
            font-size: 0.5rem;
            letter-spacing: 1px;
            border-radius: 4px;
            text-align: center;
            width: 100%;
        }
        .coin-hover-panel .status-badge.critical {
            background: rgba(220, 38, 38, 0.2);
            color: var(--danger-red);
            border: 1px solid rgba(220, 38, 38, 0.4);
        }
        .coin-hover-panel .status-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.4);
        }
        .coin-hover-panel .status-badge.stable {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        /* Responsive */
        @media (max-width: 1000px) {
            .status-panel { display: none; }
            .coins-arena { width: 95%; }
        }
        @media (max-width: 600px) {
            .crash-coin { width: 70px; height: 70px; }
            .coin-body { width: 55px; height: 55px; }
            .coin-body img { width: 30px; height: 30px; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="unified-header">
        <div class="unified-left">
            <a href="index.html" class="unified-logo">COINWIZZ</a>
            <nav class="unified-nav">
                <a href="index.html" class="unified-nav-link">HOME</a>
                <a href="moonshot-control.html" class="unified-nav-link">MOONSHOT</a>
                <a href="starbase.html" class="unified-nav-link">STARBASE</a>
                <a href="gravity.html" class="unified-nav-link">GRAVITY</a>
            </nav>
        </div>
        <div class="unified-utils">
            <a href="preise.html" class="unified-btn">PRICING</a>
            <a href="about.html" class="unified-btn">ABOUT</a>
        </div>
    </header>

    <!-- The Hall -->
    <div class="crashes-hall">
        <!-- Pillars -->
        <div class="pillars" id="pillars"></div>

        <!-- Dust -->
        <div class="dust-container" id="dustContainer"></div>

        <!-- Title -->
        <div class="room-title">
            <h1>THE GREAT CRASHES ROOM</h1>
            <div class="subtitle">MARKET GRAVITY VISUALIZATION</div>
        </div>

        <!-- Left Panel -->
        <div class="status-panel left">
            <div class="panel-title">MARKET STRESS</div>
            <div class="panel-row">
                <span class="panel-label">24H CHANGE</span>
                <span class="panel-value danger" id="marketChange">--</span>
            </div>
            <div class="panel-row">
                <span class="panel-label">VOLATILITY</span>
                <span class="panel-value" id="volatility">--</span>
            </div>
            <div class="panel-row">
                <span class="panel-label">COINS DOWN</span>
                <span class="panel-value danger" id="coinsDown">--</span>
            </div>
            <div class="panel-row">
                <span class="panel-label">SEVERITY</span>
                <span class="panel-value" id="severity">STABLE</span>
            </div>
            <div class="fear-gauge">
                <div class="fear-label">FEAR & GREED INDEX</div>
                <div class="fear-bar">
                    <div class="fear-indicator" id="fearIndicator" style="left: 50%"></div>
                </div>
                <div class="fear-value" id="fearValue">50 - Neutral</div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="status-panel right">
            <div class="panel-title">IMPACT LOG</div>
            <div class="event-feed" id="eventFeed">
                <div class="event-item">
                    <span class="time">--:--</span>
                    Awaiting market data...
                </div>
            </div>
        </div>

        <!-- Floor with cracks -->
        <div class="floor">
            <div class="floor-tiles"></div>
            <div id="floorCracks"></div>
        </div>

        <!-- Coins Arena -->
        <div class="coins-arena" id="coinsArena"></div>

        <!-- Craters -->
        <div id="craters"></div>
    </div>

    <!-- Sound Controls -->
    <div class="sound-controls">
        <div class="sound-toggle">
            <span>SOUND</span>
            <button class="sound-toggle-btn" id="soundToggle" onclick="toggleSound()"></button>
        </div>
        <div class="sound-intensity">
            <span class="intensity-label">INTENSITY</span>
            <input type="range" class="intensity-slider" id="intensitySlider" min="0" max="100" value="50" oninput="setIntensity(this.value)">
        </div>
        <div class="sound-hint">Sound enhances visualization</div>
    </div>

    <!-- Rumble Indicator -->
    <div class="rumble-indicator">
        <div class="rumble-bars" id="rumbleBars">
            <div class="rumble-bar" style="height: 5px"></div>
            <div class="rumble-bar" style="height: 8px"></div>
            <div class="rumble-bar" style="height: 12px"></div>
            <div class="rumble-bar" style="height: 8px"></div>
            <div class="rumble-bar" style="height: 5px"></div>
        </div>
        <span class="rumble-label">SEISMIC ACTIVITY</span>
    </div>

    <!-- Coin Hover Panel -->
    <div class="coin-hover-panel" id="coinHoverPanel"></div>

    <!-- Footer -->
    <div class="footer-disclaimer">
        VISUALIZATION ONLY &bull; NO TRADING SIGNALS &bull; NO FINANCIAL ADVICE
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            API_URL: 'https://api.coingecko.com/api/v3',
            UPDATE_INTERVAL: 30000,
            MAX_COINS: 12,
            CRASH_THRESHOLD: -5, // % for shake
            SEVERE_THRESHOLD: -10, // % for fall
        };

        // ==================== STATE ====================
        let cryptoData = [];
        let fallenCoins = new Set();
        let eventLog = [];
        let audioContext = null;
        let marketStress = 0;
        
        // Sound System State
        let soundEnabled = false;
        let soundIntensity = 0.5; // 0-1
        let masterGain = null;
        let ambienceNode = null;
        let ambienceGain = null;
        let activeAudioSources = [];
        let lastCrackTime = 0;
        let lastShockTime = 0;
        let lastCapitulationTime = 0;
        let ducking = false;
        let isTabVisible = true;
        const MAX_AUDIO_SOURCES = 10;

        // ==================== AUDIO ENGINE ====================
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.value = soundEnabled ? soundIntensity * 0.6 : 0;
            }
            return audioContext;
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').classList.toggle('active', soundEnabled);
            
            if (audioContext && masterGain) {
                masterGain.gain.linearRampToValueAtTime(
                    soundEnabled ? soundIntensity * 0.6 : 0,
                    audioContext.currentTime + 0.3
                );
            }
            
            if (soundEnabled) {
                initAudio();
                startAmbience();
            } else {
                stopAmbience();
            }
        }

        function setIntensity(value) {
            soundIntensity = value / 100;
            if (audioContext && masterGain && soundEnabled) {
                masterGain.gain.linearRampToValueAtTime(
                    soundIntensity * 0.6,
                    audioContext.currentTime + 0.2
                );
            }
            if (ambienceGain && soundEnabled) {
                ambienceGain.gain.linearRampToValueAtTime(
                    0.08 * soundIntensity,
                    audioContext.currentTime + 0.2
                );
            }
        }

        // Track active sources
        function trackSource(source) {
            activeAudioSources.push(source);
            if (activeAudioSources.length > MAX_AUDIO_SOURCES) {
                const old = activeAudioSources.shift();
                try { old.stop(); } catch(e) {}
            }
            source.onended = () => {
                const idx = activeAudioSources.indexOf(source);
                if (idx > -1) activeAudioSources.splice(idx, 1);
            };
        }

        // ==================== AMBIENCE (Always Active) ====================
        function startAmbience() {
            if (!soundEnabled || ambienceNode) return;
            const ctx = initAudio();
            
            // Deep room tone with brown noise
            const bufferSize = ctx.sampleRate * 4;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 2;
            }
            
            ambienceNode = ctx.createBufferSource();
            ambienceNode.buffer = buffer;
            ambienceNode.loop = true;
            
            const lowpass = ctx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 60 + marketStress * 0.5;
            
            const reverb = ctx.createConvolver();
            // Create simple reverb impulse
            const reverbBuffer = ctx.createBuffer(2, ctx.sampleRate * 2, ctx.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const d = reverbBuffer.getChannelData(ch);
                for (let i = 0; i < d.length; i++) {
                    d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.5));
                }
            }
            reverb.buffer = reverbBuffer;
            
            ambienceGain = ctx.createGain();
            ambienceGain.gain.value = 0.08 * soundIntensity;
            
            ambienceNode.connect(lowpass);
            lowpass.connect(reverb);
            reverb.connect(ambienceGain);
            ambienceGain.connect(masterGain);
            
            ambienceNode.start();
        }

        function stopAmbience() {
            if (ambienceNode) {
                try { ambienceNode.stop(); } catch(e) {}
                ambienceNode = null;
                ambienceGain = null;
            }
        }

        function updateAmbienceForStress() {
            if (!soundEnabled || !ambienceGain) return;
            // More stress = deeper rumble, more reverb
            const intensity = 0.06 + (marketStress / 100) * 0.08;
            ambienceGain.gain.linearRampToValueAtTime(
                intensity * soundIntensity,
                audioContext.currentTime + 0.5
            );
        }

        // ==================== ELEMENT SOUNDS ====================
        
        // Floor Stress Creak (subtle stone stress)
        function playFloorCreak() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const bufferSize = ctx.sampleRate * 0.8;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const t = i / ctx.sampleRate;
                const freq = 100 + Math.sin(t * 20) * 30;
                data[i] = Math.sin(t * freq * Math.PI * 2) * Math.exp(-t * 3) * 0.3;
                data[i] += (Math.random() * 2 - 1) * Math.exp(-t * 5) * 0.1;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.15 * soundIntensity * (ducking ? 0.3 : 1);
            
            source.connect(gain);
            gain.connect(masterGain);
            source.start();
            trackSource(source);
        }

        // Crack Clicks (stone splitting - rate limited)
        function playCrackClick() {
            if (!soundEnabled || !isTabVisible) return;
            const now = Date.now();
            if (now - lastCrackTime < 500) return; // Max 2 per second
            lastCrackTime = now;
            
            const ctx = initAudio();
            
            const bufferSize = ctx.sampleRate * 0.3;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const t = i / ctx.sampleRate;
                data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 20);
                // Add some "click" transient
                if (t < 0.01) data[i] *= 3;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const highpass = ctx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = 800;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.18 * soundIntensity * (ducking ? 0.3 : 1);
            
            source.connect(highpass);
            highpass.connect(gain);
            gain.connect(masterGain);
            source.start();
            trackSource(source);
        }

        // Pillar Groan (deep structural stress)
        function playPillarGroan() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const duration = 1.5;
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const t = i / ctx.sampleRate;
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                // Envelope
                const env = Math.sin(t / duration * Math.PI);
                data[i] *= env * 3;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const lowpass = ctx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 120;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.25 * soundIntensity * (ducking ? 0.3 : 1);
            
            source.connect(lowpass);
            lowpass.connect(gain);
            gain.connect(masterGain);
            source.start();
            trackSource(source);
        }

        // Dust Whoosh (subtle air movement)
        function playDustWhoosh() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const bufferSize = ctx.sampleRate * 0.6;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const t = i / ctx.sampleRate;
                data[i] = (Math.random() * 2 - 1) * Math.sin(t / 0.6 * Math.PI) * 0.3;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const bandpass = ctx.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = 2000;
            bandpass.Q.value = 0.5;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.06 * soundIntensity;
            
            source.connect(bandpass);
            bandpass.connect(gain);
            gain.connect(masterGain);
            source.start();
            trackSource(source);
        }

        // Coin Rattle (metallic pre-drop warning)
        function playCoinRattle() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const osc = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'triangle';
            osc.frequency.value = 800;
            osc2.type = 'triangle';
            osc2.frequency.value = 1200;
            
            // Tremolo effect
            const tremolo = ctx.createGain();
            const lfo = ctx.createOscillator();
            lfo.frequency.value = 15;
            const lfoGain = ctx.createGain();
            lfoGain.gain.value = 0.5;
            lfo.connect(lfoGain);
            lfoGain.connect(tremolo.gain);
            
            gain.gain.setValueAtTime(0.04 * soundIntensity, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
            
            osc.connect(tremolo);
            osc2.connect(tremolo);
            tremolo.connect(gain);
            gain.connect(masterGain);
            
            lfo.start();
            osc.start();
            osc2.start();
            osc.stop(ctx.currentTime + 0.4);
            osc2.stop(ctx.currentTime + 0.4);
            lfo.stop(ctx.currentTime + 0.4);
        }

        // Coin Impact (heavy metallic thud with reverb)
        function playCoinImpact(intensity = 1) {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            // Sub bass hit
            const osc = ctx.createOscillator();
            const oscGain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(80, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(25, ctx.currentTime + 0.4);
            oscGain.gain.setValueAtTime(0.5 * intensity * soundIntensity, ctx.currentTime);
            oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.6);
            osc.connect(oscGain);
            oscGain.connect(masterGain);
            osc.start();
            osc.stop(ctx.currentTime + 0.6);
            
            // Metallic clang
            const clangBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.8, ctx.sampleRate);
            const clangData = clangBuffer.getChannelData(0);
            for (let i = 0; i < clangData.length; i++) {
                const t = i / ctx.sampleRate;
                clangData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 8);
                clangData[i] += Math.sin(t * 400 * Math.PI * 2) * Math.exp(-t * 6) * 0.3;
            }
            const clang = ctx.createBufferSource();
            clang.buffer = clangBuffer;
            
            const clangGain = ctx.createGain();
            clangGain.gain.value = 0.2 * intensity * soundIntensity;
            
            clang.connect(clangGain);
            clangGain.connect(masterGain);
            clang.start();
            trackSource(clang);
        }

        // ==================== EVENT SOUNDS ====================
        
        // Shock Wave (sudden market drop)
        function playShockWave() {
            if (!soundEnabled || !isTabVisible) return;
            const now = Date.now();
            if (now - lastShockTime < 4000) return; // 4s cooldown
            lastShockTime = now;
            
            // Duck other sounds
            applyDucking();
            
            const ctx = initAudio();
            
            // Deep sub impact
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(50, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.6 * soundIntensity, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.8);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(ctx.currentTime + 0.8);
            
            // Room burst noise
            const burstBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
            const burstData = burstBuffer.getChannelData(0);
            for (let i = 0; i < burstData.length; i++) {
                const t = i / ctx.sampleRate;
                burstData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 6);
            }
            const burst = ctx.createBufferSource();
            burst.buffer = burstBuffer;
            const burstGain = ctx.createGain();
            burstGain.gain.value = 0.25 * soundIntensity;
            const lowpass = ctx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 300;
            burst.connect(lowpass);
            lowpass.connect(burstGain);
            burstGain.connect(masterGain);
            burst.start();
            trackSource(burst);
        }

        // Capitulation Drop (major crash event)
        function playCapitulationDrop() {
            if (!soundEnabled || !isTabVisible) return;
            const now = Date.now();
            if (now - lastCapitulationTime < 8000) return; // 8s cooldown
            lastCapitulationTime = now;
            
            applyDucking();
            
            const ctx = initAudio();
            
            // Heavy collapse hit
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(40, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(15, ctx.currentTime + 1);
            gain.gain.setValueAtTime(0.7 * soundIntensity, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.3 * soundIntensity, ctx.currentTime + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(ctx.currentTime + 2);
            
            // Long reverb tail
            const reverbBuffer = ctx.createBuffer(2, ctx.sampleRate * 3, ctx.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const d = reverbBuffer.getChannelData(ch);
                for (let i = 0; i < d.length; i++) {
                    d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.8));
                }
            }
            const reverb = ctx.createConvolver();
            reverb.buffer = reverbBuffer;
            
            const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.1));
            }
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            const noiseGain = ctx.createGain();
            noiseGain.gain.value = 0.4 * soundIntensity;
            noise.connect(reverb);
            reverb.connect(noiseGain);
            noiseGain.connect(masterGain);
            noise.start();
            trackSource(noise);
            
            // Trigger "After Silence"
            setTimeout(playAfterSilence, 2500);
        }

        // After Silence (psychological pause)
        function playAfterSilence() {
            if (!soundEnabled || !masterGain) return;
            const ctx = audioContext;
            
            // Dramatically reduce all volume for 1.5s
            masterGain.gain.linearRampToValueAtTime(0.05 * soundIntensity, ctx.currentTime + 0.3);
            
            setTimeout(() => {
                if (masterGain && soundEnabled) {
                    masterGain.gain.linearRampToValueAtTime(soundIntensity * 0.6, audioContext.currentTime + 1);
                }
                ducking = false;
            }, 1500);
        }

        // Sidechain Ducking
        function applyDucking() {
            if (!masterGain || ducking) return;
            ducking = true;
            
            // Reduce ambience and other sounds
            if (ambienceGain) {
                ambienceGain.gain.linearRampToValueAtTime(
                    0.02 * soundIntensity,
                    audioContext.currentTime + 0.1
                );
            }
            
            setTimeout(() => {
                if (ambienceGain && soundEnabled && !ducking) {
                    ambienceGain.gain.linearRampToValueAtTime(
                        0.08 * soundIntensity,
                        audioContext.currentTime + 0.5
                    );
                }
            }, 1500);
        }

        // Deep rumble (enhanced)
        function playRumble(intensity = 0.3, duration = 2) {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5;
            }
            
            const noise = ctx.createBufferSource();
            noise.buffer = buffer;
            
            const lowpass = ctx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 80;
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(intensity, ctx.currentTime + 0.3);
            gain.gain.linearRampToValueAtTime(intensity * 0.7, ctx.currentTime + duration - 0.5);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
            
            noise.connect(lowpass);
            lowpass.connect(gain);
            gain.connect(masterGain);
            
            noise.start(ctx.currentTime);
            noise.stop(ctx.currentTime + duration);
            trackSource(noise);
        }

        // Stone crack sound (enhanced)
        function playCrack() {
            playCrackClick();
        }

        // Impact thud (enhanced)
        function playImpact() {
            playCoinImpact(1);
            playDustWhoosh();
            if (marketStress > 70) {
                playCapitulationDrop();
            } else {
                playShockWave();
            }
        }

        // ==================== FUTURISTIC HOVER SOUNDS ====================
        let lastHoverSoundTime = 0;
        const HOVER_SOUND_COOLDOWN = 350; // ms
        
        // Sci-Fi Sound Type 1: Elektrisches Aufladen
        function playElectricCharge() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const duration = 0.4;
            const osc = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const gain = ctx.createGain();
            const filter = ctx.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + duration * 0.3);
            osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + duration);
            
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(1200, ctx.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(2400, ctx.currentTime + duration * 0.5);
            
            filter.type = 'bandpass';
            filter.frequency.value = 1500;
            filter.Q.value = 2;
            
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.08 * soundIntensity, ctx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
            
            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc.start(); osc2.start();
            osc.stop(ctx.currentTime + duration);
            osc2.stop(ctx.currentTime + duration);
        }
        
        // Sci-Fi Sound Type 2: Laser Ping
        function playLaserPing() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const duration = 0.35;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(2800, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + duration);
            
            gain.gain.setValueAtTime(0.1 * soundIntensity, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
            
            osc.connect(gain);
            gain.connect(masterGain);
            
            osc.start();
            osc.stop(ctx.currentTime + duration);
        }
        
        // Sci-Fi Sound Type 3: Digitaler Impuls
        function playDigitalPulse() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const duration = 0.3;
            const osc = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'square';
            osc.frequency.value = 880;
            osc2.type = 'square';
            osc2.frequency.value = 1320;
            
            // Schnelles Pulsieren
            const lfo = ctx.createOscillator();
            const lfoGain = ctx.createGain();
            lfo.frequency.value = 40;
            lfoGain.gain.value = 0.5;
            lfo.connect(lfoGain);
            lfoGain.connect(gain.gain);
            
            gain.gain.setValueAtTime(0.06 * soundIntensity, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 600;
            
            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            lfo.start(); osc.start(); osc2.start();
            lfo.stop(ctx.currentTime + duration);
            osc.stop(ctx.currentTime + duration);
            osc2.stop(ctx.currentTime + duration);
        }
        
        // Sci-Fi Sound Type 4: Strom-Impuls
        function playElectricTick() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const duration = 0.25;
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const t = i / ctx.sampleRate;
                // Kurzer Knack + Sine-Tail
                const click = t < 0.01 ? (Math.random() * 2 - 1) * (1 - t / 0.01) : 0;
                const sine = Math.sin(t * 1800 * Math.PI * 2) * Math.exp(-t * 15);
                data[i] = (click * 0.5 + sine * 0.5);
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.1 * soundIntensity;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 800;
            
            source.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            source.start();
            trackSource(source);
        }
        
        // Sci-Fi Sound Type 5: Navigation Beep
        function playNavBeep() {
            if (!soundEnabled || !isTabVisible) return;
            const ctx = initAudio();
            
            const duration = 0.4;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sine';
            // Zwei-Ton Beep
            osc.frequency.setValueAtTime(1400, ctx.currentTime);
            osc.frequency.setValueAtTime(1800, ctx.currentTime + 0.1);
            osc.frequency.setValueAtTime(1400, ctx.currentTime + 0.2);
            
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.08 * soundIntensity, ctx.currentTime + 0.02);
            gain.gain.setValueAtTime(0.08 * soundIntensity, ctx.currentTime + 0.15);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
            
            osc.connect(gain);
            gain.connect(masterGain);
            
            osc.start();
            osc.stop(ctx.currentTime + duration);
        }
        
        // Hauptfunktion: Zuflliger Hover-Sound
        const hoverSoundFunctions = [
            playElectricCharge,
            playLaserPing,
            playDigitalPulse,
            playElectricTick,
            playNavBeep
        ];
        
        function playHoverSound(coinChange) {
            const now = Date.now();
            if (now - lastHoverSoundTime < HOVER_SOUND_COOLDOWN) return;
            lastHoverSoundTime = now;
            
            if (!soundEnabled || !isTabVisible) return;
            initAudio();
            
            // Sound-Auswahl basierend auf Coin-Status oder zufllig
            let soundIndex;
            if (coinChange < -10) {
                // Kritisch: Strom-Impuls
                soundIndex = 3;
            } else if (coinChange < -5) {
                // Unter Druck: Digital Pulse
                soundIndex = 2;
            } else {
                // Normal: Zufllig
                soundIndex = Math.floor(Math.random() * hoverSoundFunctions.length);
            }
            
            hoverSoundFunctions[soundIndex]();
        }

        // ==================== VISUAL SETUP ====================
        function createPillars() {
            const container = document.getElementById('pillars');
            const positions = [5, 15, 85, 95];
            
            positions.forEach((pos, i) => {
                const pillar = document.createElement('div');
                pillar.className = 'pillar';
                pillar.style.left = pos + '%';
                pillar.style.height = (60 + Math.random() * 30) + '%';
                pillar.dataset.index = i;
                container.appendChild(pillar);
            });
        }

        function createDust() {
            const container = document.getElementById('dustContainer');
            for (let i = 0; i < 40; i++) {
                const dust = document.createElement('div');
                dust.className = 'dust';
                dust.style.left = Math.random() * 100 + '%';
                dust.style.animationDelay = Math.random() * 8 + 's';
                dust.style.animationDuration = (6 + Math.random() * 4) + 's';
                container.appendChild(dust);
            }
        }

        function addFloorCrack(x) {
            const container = document.getElementById('floorCracks');
            const crack = document.createElement('div');
            crack.className = 'floor-crack';
            crack.style.left = x + '%';
            crack.style.setProperty('--rotation', (Math.random() * 30 - 15) + 'deg');
            container.appendChild(crack);
            
            setTimeout(() => {
                crack.classList.add('visible');
                playCrack();
            }, 100);
            
            return crack;
        }

        // ==================== DATA FETCHING ====================
        async function fetchCryptoData() {
            try {
                const response = await fetch(
                    `${CONFIG.API_URL}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false&price_change_percentage=24h`
                );
                const data = await response.json();
                cryptoData = data;
                
                updateDisplay();
                updatePanels();
                calculateMarketStress();
            } catch (error) {
                console.error('Data fetch error:', error);
            }
        }

        // ==================== DISPLAY ====================
        function updateDisplay() {
            const container = document.getElementById('coinsArena');
            container.innerHTML = '';
            
            // Get worst performers
            const worstCoins = [...cryptoData]
                .sort((a, b) => a.price_change_percentage_24h - b.price_change_percentage_24h)
                .slice(0, CONFIG.MAX_COINS);
            
            worstCoins.forEach((coin, index) => {
                const change = coin.price_change_percentage_24h || 0;
                const coinEl = createCoinElement(coin, change, index);
                container.appendChild(coinEl);
                
                // Apply stress animations
                if (change < CONFIG.SEVERE_THRESHOLD && !fallenCoins.has(coin.id)) {
                    setTimeout(() => triggerFall(coin, coinEl), 2000 + index * 1500);
                } else if (change < CONFIG.CRASH_THRESHOLD) {
                    coinEl.classList.add('shaking');
                } else if (change < 0) {
                    coinEl.classList.add('sinking');
                }
            });
        }

        function createCoinElement(coin, change, index) {
            const el = document.createElement('div');
            el.className = 'crash-coin';
            el.dataset.coinId = coin.id;
            el.dataset.coinIndex = index;
            
            // Hover events
            el.addEventListener('mouseenter', (e) => {
                showCoinPanel(coin, e);
                playHoverSound(change);
            });
            el.addEventListener('mousemove', (e) => moveCoinPanel(e));
            el.addEventListener('mouseleave', hideCoinPanel);
            
            const changeClass = change >= 0 ? 'positive' : 'negative';
            const changeStr = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
            
            el.innerHTML = `
                <div class="coin-body">
                    <img src="${coin.image}" alt="${coin.symbol}" onerror="this.style.display='none'">
                </div>
                <div class="coin-data">
                    <div class="coin-symbol">${coin.symbol.toUpperCase()}</div>
                    <div class="coin-change ${changeClass}">${changeStr}</div>
                </div>
            `;
            
            return el;
        }

        // ==================== CRASH MECHANICS ====================
        function triggerFall(coin, element) {
            if (fallenCoins.has(coin.id)) return;
            fallenCoins.add(coin.id);
            
            addEvent(`${coin.symbol.toUpperCase()} collapsed - ${coin.price_change_percentage_24h.toFixed(1)}%`);
            
            // Play coin rattle before fall
            if (soundEnabled) playCoinRattle();
            
            // Add floor crack
            const rect = element.getBoundingClientRect();
            const crackX = (rect.left + rect.width / 2) / window.innerWidth * 100;
            addFloorCrack(crackX);
            
            // Crack pillar if severe
            if (coin.price_change_percentage_24h < -15) {
                const pillars = document.querySelectorAll('.pillar:not(.cracked)');
                if (pillars.length > 0) {
                    pillars[0].classList.add('cracked');
                    if (soundEnabled) playPillarGroan();
                }
            }
            
            // Play rumble and dust
            if (soundEnabled) {
                playRumble(0.4, 3);
                playDustWhoosh();
            }
            
            setTimeout(() => {
                element.classList.remove('shaking', 'sinking');
                element.classList.add('falling');
                
                setTimeout(() => {
                    if (soundEnabled) playImpact();
                }, 2500);
            }, 500);
        }

        function calculateMarketStress() {
            const changes = cryptoData.map(c => c.price_change_percentage_24h || 0);
            const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
            const negativeCount = changes.filter(c => c < 0).length;
            
            const prevStress = marketStress;
            
            // Calculate stress 0-100
            marketStress = Math.min(100, Math.max(0, 
                50 - avgChange * 3 + (negativeCount / changes.length) * 30
            ));
            
            // Update fear indicator
            document.getElementById('fearIndicator').style.left = (100 - marketStress) + '%';
            
            let fearText = 'Neutral';
            if (marketStress > 75) fearText = 'Extreme Fear';
            else if (marketStress > 60) fearText = 'Fear';
            else if (marketStress < 25) fearText = 'Extreme Greed';
            else if (marketStress < 40) fearText = 'Greed';
            
            document.getElementById('fearValue').textContent = 
                Math.round(100 - marketStress) + ' - ' + fearText;
            
            // Update seismic bars
            updateRumbleBars();
            
            // Sound responses to stress changes
            if (soundEnabled) {
                updateAmbienceForStress();
                
                // Sudden stress spike = shock wave
                if (marketStress - prevStress > 15) {
                    playShockWave();
                }
                
                // High stress = floor creaks
                if (marketStress > 60 && Math.random() < 0.3) {
                    playFloorCreak();
                }
                
                // Very high stress = pillar groans
                if (marketStress > 75 && Math.random() < 0.2) {
                    playPillarGroan();
                }
            }
        }

        function updateRumbleBars() {
            const bars = document.querySelectorAll('.rumble-bar');
            bars.forEach((bar, i) => {
                const baseHeight = [5, 8, 12, 8, 5][i];
                const stressMultiplier = 1 + (marketStress / 50);
                const randomFactor = 0.5 + Math.random();
                bar.style.height = (baseHeight * stressMultiplier * randomFactor) + 'px';
            });
        }

        // ==================== PANELS ====================
        function updatePanels() {
            const changes = cryptoData.map(c => c.price_change_percentage_24h || 0);
            const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
            const negativeCount = changes.filter(c => c < 0).length;
            
            // Calculate volatility (std deviation)
            const variance = changes.reduce((sum, c) => sum + Math.pow(c - avgChange, 2), 0) / changes.length;
            const volatility = Math.sqrt(variance);
            
            document.getElementById('marketChange').textContent = avgChange.toFixed(2) + '%';
            document.getElementById('marketChange').className = 'panel-value ' + (avgChange < 0 ? 'danger' : '');
            
            document.getElementById('volatility').textContent = volatility.toFixed(1) + '%';
            document.getElementById('volatility').className = 'panel-value ' + (volatility > 5 ? 'warning' : '');
            
            document.getElementById('coinsDown').textContent = negativeCount + '/' + cryptoData.length;
            
            // Severity
            let severity = 'STABLE';
            let severityClass = '';
            if (avgChange < -5) { severity = 'SEVERE'; severityClass = 'danger'; }
            else if (avgChange < -2) { severity = 'STRESSED'; severityClass = 'warning'; }
            else if (avgChange < 0) { severity = 'CAUTIOUS'; severityClass = 'warning'; }
            
            document.getElementById('severity').textContent = severity;
            document.getElementById('severity').className = 'panel-value ' + severityClass;
        }

        function addEvent(text) {
            const time = new Date().toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            eventLog.unshift({ text, time });
            eventLog = eventLog.slice(0, 10);
            
            const container = document.getElementById('eventFeed');
            container.innerHTML = eventLog.map(e => `
                <div class="event-item">
                    <span class="time">${e.time}</span>
                    ${e.text}
                </div>
            `).join('');
        }

        // ==================== COIN HOVER PANEL ====================
        const coinHoverPanel = document.getElementById('coinHoverPanel');
        
        function showCoinPanel(coin, e) {
            const change = coin.price_change_percentage_24h || 0;
            const changeClass = change >= 0 ? 'positive' : 'negative';
            
            // Status ermitteln
            let statusClass = 'stable';
            let statusText = 'STABIL';
            if (change < -10) { statusClass = 'critical'; statusText = 'KRITISCH  KOLLAPS'; }
            else if (change < -5) { statusClass = 'warning'; statusText = 'UNTER DRUCK'; }
            else if (change < 0) { statusClass = 'warning'; statusText = 'SINKEND'; }
            
            // Formatierung
            const price = coin.current_price ? (coin.current_price < 1 ? coin.current_price.toFixed(6) : coin.current_price.toLocaleString('de-DE', {maximumFractionDigits: 2})) : '--';
            const marketCap = coin.market_cap ? (coin.market_cap / 1e9).toFixed(2) + ' Mrd.' : '--';
            const volume = coin.total_volume ? (coin.total_volume / 1e6).toFixed(1) + ' Mio.' : '--';
            const high24 = coin.high_24h ? '$' + coin.high_24h.toLocaleString('de-DE', {maximumFractionDigits: 2}) : '--';
            const low24 = coin.low_24h ? '$' + coin.low_24h.toLocaleString('de-DE', {maximumFractionDigits: 2}) : '--';
            const ath = coin.ath ? '$' + coin.ath.toLocaleString('de-DE', {maximumFractionDigits: 2}) : '--';
            const athChange = coin.ath_change_percentage ? coin.ath_change_percentage.toFixed(1) + '%' : '--';
            
            coinHoverPanel.innerHTML = `
                <div class="panel-header">
                    <img src="${coin.image}" alt="${coin.symbol}" onerror="this.style.display='none'">
                    <div>
                        <div class="coin-name">${coin.name}</div>
                        <div class="coin-sym">${coin.symbol.toUpperCase()}</div>
                    </div>
                </div>
                <div class="data-row">
                    <span class="data-label">PREIS</span>
                    <span class="data-value">$${price}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">24H</span>
                    <span class="data-value ${changeClass}">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</span>
                </div>
                <div class="data-row">
                    <span class="data-label">MARKTK.</span>
                    <span class="data-value">$${marketCap}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">VOLUMEN</span>
                    <span class="data-value">$${volume}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">24H HOCH</span>
                    <span class="data-value">${high24}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">24H TIEF</span>
                    <span class="data-value">${low24}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">ATH</span>
                    <span class="data-value">${ath}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">VOM ATH</span>
                    <span class="data-value negative">${athChange}</span>
                </div>
                <div class="status-badge ${statusClass}">${statusText}</div>
            `;
            
            moveCoinPanel(e);
            coinHoverPanel.classList.add('visible');
        }
        
        function moveCoinPanel(e) {
            const panel = coinHoverPanel;
            const padding = 15;
            let x = e.clientX + padding;
            let y = e.clientY + padding;
            
            // Rechts berlauf
            if (x + panel.offsetWidth > window.innerWidth - padding) {
                x = e.clientX - panel.offsetWidth - padding;
            }
            // Unten berlauf
            if (y + panel.offsetHeight > window.innerHeight - padding) {
                y = e.clientY - panel.offsetHeight - padding;
            }
            
            panel.style.left = x + 'px';
            panel.style.top = y + 'px';
        }
        
        function hideCoinPanel() {
            coinHoverPanel.classList.remove('visible');
        }

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', () => {
            createPillars();
            createDust();
            fetchCryptoData();
            
            setInterval(fetchCryptoData, CONFIG.UPDATE_INTERVAL);
            setInterval(updateRumbleBars, 200);
            
            addEvent('Crashes Room initialized');
        });

        // Tab visibility handling (pause audio when hidden)
        document.addEventListener('visibilitychange', () => {
            isTabVisible = !document.hidden;
            if (!isTabVisible && ambienceNode) {
                stopAmbience();
            } else if (isTabVisible && soundEnabled) {
                startAmbience();
            }
        });

        // Enable audio on first interaction
        document.addEventListener('click', () => {
            initAudio();
            if (soundEnabled) startAmbience();
        }, { once: true });
    </script>
</body>
</html>
