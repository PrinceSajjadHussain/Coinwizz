<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Galaxy - CryptoSpaces</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=JetBrains+Mono:wght@400;500&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary-blue: #3b82f6;
            --secondary-blue: #06b6d4;
            --dark-bg: #0f172a;
            --darker-bg: #1e1b4b;
            --text-light: #f8fafc;
            --glow-blue: rgba(59, 130, 246, 0.6);
            --success-green: #10b981;
            --danger-red: #ef4444;
            --state-warm: #f59e0b;
            --bank-neutral: #6b7280;
            --crypto-cold: #06b6d4;
            --exchange-purple: #8b5cf6;
        }
        body {
            font-family: 'Orbitron', sans-serif;
            background: radial-gradient(ellipse at center, #0a0f1e 0%, #050810 50%, #000 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: var(--text-light);
        }
        /* Header */
        .header {
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 100;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95) 0%, transparent 100%);
        }
        .header-left { display: flex; align-items: center; gap: 20px; }
        .title {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--primary-blue), var(--secondary-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
        }
        .back-btn {
            background: rgba(59,130,246,0.15);
            border: 1px solid rgba(59,130,246,0.4);
            color: var(--primary-blue);
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }
        .back-btn:hover { background: rgba(59,130,246,0.25); }

        /* Controls Panel */
        .controls-panel {
            position: fixed;
            top: 70px; left: 20px;
            background: rgba(10, 15, 30, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 15px;
            z-index: 90;
            min-width: 200px;
        }
        .controls-title {
            font-size: 0.7rem;
            color: rgba(248,250,252,0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(59,130,246,0.2);
        }
        .layer-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            cursor: pointer;
        }
        .layer-toggle label { font-size: 0.7rem; color: var(--text-light); cursor: pointer; }
        .toggle-switch {
            width: 36px; height: 18px;
            background: rgba(75, 85, 99, 0.5);
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active { background: linear-gradient(135deg, #3b82f6, #06b6d4); }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px;
            width: 14px; height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch.active::after { transform: translateX(18px); }
        .speed-control { margin-top: 15px; }
        .speed-control label { font-size: 0.65rem; color: rgba(248,250,252,0.6); display: block; margin-bottom: 5px; }
        .speed-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(59,130,246,0.3);
            border-radius: 2px;
            outline: none;
        }
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
        }
        .control-buttons { display: flex; gap: 8px; margin-top: 15px; }
        .ctrl-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid rgba(59,130,246,0.4);
            background: rgba(59,130,246,0.1);
            color: var(--primary-blue);
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ctrl-btn:hover { background: rgba(59,130,246,0.2); }
        .ctrl-btn.active { background: var(--primary-blue); color: white; }

        /* Galaxy Canvas */
        #galaxy-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }

        /* Hover Overlay Panel */
        .hover-panel {
            position: fixed;
            display: none;
            background: rgba(10, 15, 30, 0.95);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 16px;
            padding: 0;
            z-index: 200;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 30px rgba(59,130,246,0.2);
            overflow: hidden;
        }
        .hover-panel.visible { display: block; }
        .panel-header {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(59,130,246,0.2);
        }
        .panel-header-left { display: flex; align-items: center; gap: 10px; }
        .panel-icon { font-size: 1.5rem; }
        .panel-title { font-size: 0.9rem; font-weight: 700; letter-spacing: 1px; }
        .status-badge {
            font-size: 0.55rem;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .status-live { background: rgba(16,185,129,0.2); color: #10b981; border: 1px solid rgba(16,185,129,0.4); }
        .status-spike { background: rgba(239,68,68,0.2); color: #ef4444; border: 1px solid rgba(239,68,68,0.4); animation: pulse 1s infinite; }
        .status-simulated { background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid rgba(251,191,36,0.4); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .panel-body { padding: 16px; }
        .panel-description { font-size: 0.7rem; color: rgba(248,250,252,0.7); line-height: 1.5; margin-bottom: 15px; }
        .panel-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px; }
        .stat-item {
            background: rgba(59,130,246,0.08);
            border-radius: 8px;
            padding: 10px;
        }
        .stat-label { font-size: 0.55rem; color: rgba(248,250,252,0.5); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .stat-value { font-size: 0.85rem; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
        .stat-change { font-size: 0.6rem; margin-top: 2px; }
        .stat-change.positive { color: #10b981; }
        .stat-change.negative { color: #ef4444; }
        .sparkline-container { margin-bottom: 15px; }
        .sparkline-label { font-size: 0.6rem; color: rgba(248,250,252,0.5); margin-bottom: 5px; }
        .sparkline { height: 40px; background: rgba(59,130,246,0.05); border-radius: 6px; overflow: hidden; position: relative; }
        .sparkline-line { stroke: var(--primary-blue); stroke-width: 2; fill: none; }
        .sparkline-area { fill: url(#sparkGradient); }
        .causality-box {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        .causality-title { font-size: 0.6rem; color: #a78bfa; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .causality-flow { display: flex; align-items: center; gap: 8px; font-size: 0.65rem; }
        .causality-item { padding: 4px 8px; background: rgba(139,92,246,0.2); border-radius: 4px; }
        .causality-arrow { color: rgba(248,250,252,0.4); }
        .panel-footer {
            padding: 10px 16px;
            background: rgba(0,0,0,0.2);
            border-top: 1px solid rgba(59,130,246,0.1);
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            color: rgba(248,250,252,0.4);
        }

        /* Footer Claim */
        .footer-claim {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(0deg, rgba(10,15,30,0.95) 0%, transparent 100%);
            padding: 30px 20px 15px;
            text-align: center;
            z-index: 50;
        }
        .claim-text {
            font-size: 0.7rem;
            color: rgba(248,250,252,0.5);
            font-style: italic;
            letter-spacing: 1px;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            .controls-panel {
                position: fixed;
                top: auto; bottom: 60px;
                left: 10px; right: 10px;
                transform: translateY(calc(100% + 20px));
                transition: transform 0.3s ease;
            }
            .controls-panel.visible { transform: translateY(0); }
            .mobile-toggle-btn {
                position: fixed;
                bottom: 70px; right: 20px;
                width: 50px; height: 50px;
                background: var(--primary-blue);
                border: none; border-radius: 50%;
                color: white; font-size: 1.2rem;
                cursor: pointer; z-index: 91;
                display: flex; align-items: center; justify-content: center;
            }
            .hover-panel {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important; right: 0 !important;
                top: auto !important;
                max-width: 100%;
                border-radius: 16px 16px 0 0;
                max-height: 70vh;
                overflow-y: auto;
            }
        }
        @media (min-width: 769px) { .mobile-toggle-btn { display: none; } }

        /* Actors Styling */
        .state-glow { filter: drop-shadow(0 0 30px rgba(245, 158, 11, 0.6)); }
        .bank-glow { filter: drop-shadow(0 0 20px rgba(107, 114, 128, 0.5)); }
        .crypto-glow { filter: drop-shadow(0 0 25px rgba(6, 182, 212, 0.7)); }
        .exchange-glow { filter: drop-shadow(0 0 35px rgba(139, 92, 246, 0.8)); }

        /* Market Signals History Panel */
        .history-tab {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(59,130,246,0.25), rgba(6,182,212,0.15));
            border: 1px solid rgba(59,130,246,0.5);
            border-right: none;
            border-radius: 12px 0 0 12px;
            padding: 15px 10px;
            cursor: pointer;
            z-index: 300;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: var(--primary-blue);
            letter-spacing: 2px;
            transition: all 0.3s ease;
            box-shadow: -4px 0 20px rgba(59,130,246,0.2);
        }
        .history-tab:hover {
            background: linear-gradient(135deg, rgba(59,130,246,0.4), rgba(6,182,212,0.25));
            padding-right: 15px;
        }
        .history-tab.hidden { display: none; }

        .history-panel {
            position: fixed;
            right: -420px;
            top: 80px;
            bottom: 80px;
            width: 400px;
            background: rgba(10, 15, 30, 0.95);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(59,130,246,0.4);
            border-right: none;
            border-radius: 16px 0 0 16px;
            z-index: 350;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            box-shadow: -10px 0 40px rgba(0,0,0,0.5);
        }
        .history-panel.open { right: 0; }

        .history-header {
            padding: 20px;
            border-bottom: 1px solid rgba(59,130,246,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            background: linear-gradient(90deg, var(--primary-blue), var(--secondary-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }
        .history-close {
            background: rgba(239,68,68,0.2);
            border: 1px solid rgba(239,68,68,0.4);
            color: #ef4444;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .history-close:hover { background: rgba(239,68,68,0.4); }

        .history-filters {
            padding: 15px 20px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid rgba(59,130,246,0.15);
            flex-wrap: wrap;
        }
        .filter-btn {
            padding: 6px 12px;
            border: 1px solid rgba(59,130,246,0.3);
            background: rgba(59,130,246,0.08);
            color: rgba(248,250,252,0.7);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .filter-btn:hover { background: rgba(59,130,246,0.15); }
        .filter-btn.active {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            border-color: var(--primary-blue);
            color: white;
        }

        .history-timeline {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(59,130,246,0.15);
        }
        .timeline-bar {
            height: 32px;
            background: rgba(15,23,42,0.8);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }
        .timeline-marker {
            position: absolute;
            top: 4px;
            width: 8px;
            height: 24px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timeline-marker:hover { transform: scaleY(1.2); filter: brightness(1.3); }
        .timeline-marker.central-bank { background: #f59e0b; }
        .timeline-marker.macro-data { background: #3b82f6; }
        .timeline-marker.institutional { background: #8b5cf6; }
        .timeline-marker.geopolitical { background: #ef4444; }

        .history-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
        }
        .history-content::-webkit-scrollbar { width: 4px; }
        .history-content::-webkit-scrollbar-track { background: rgba(59,130,246,0.1); }
        .history-content::-webkit-scrollbar-thumb { background: var(--primary-blue); border-radius: 2px; }

        .signal-event {
            background: rgba(59,130,246,0.06);
            border: 1px solid rgba(59,130,246,0.2);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .signal-event:hover {
            background: rgba(59,130,246,0.12);
            border-color: rgba(59,130,246,0.4);
            transform: translateX(-4px);
        }
        .signal-event.highlighted {
            background: rgba(59,130,246,0.2);
            border-color: var(--primary-blue);
            box-shadow: 0 0 20px rgba(59,130,246,0.3);
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        .event-source {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .source-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.55rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        .source-badge.central-bank { background: rgba(245,158,11,0.2); color: #f59e0b; }
        .source-badge.macro-data { background: rgba(59,130,246,0.2); color: #3b82f6; }
        .source-badge.institutional { background: rgba(139,92,246,0.2); color: #8b5cf6; }
        .source-badge.geopolitical { background: rgba(239,68,68,0.2); color: #ef4444; }
        .event-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: rgba(248,250,252,0.5);
        }
        .event-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 6px;
        }
        .event-impact {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        .impact-tag {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.55rem;
            background: rgba(6,182,212,0.15);
            color: var(--secondary-blue);
        }
        .event-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 0.6rem;
        }
        .stat-mini {
            text-align: center;
            padding: 6px;
            background: rgba(15,23,42,0.6);
            border-radius: 4px;
        }
        .stat-mini-label { color: rgba(248,250,252,0.5); margin-bottom: 2px; }
        .stat-mini-value { font-weight: 600; font-family: 'JetBrains Mono', monospace; }
        .stat-mini-value.positive { color: #10b981; }
        .stat-mini-value.negative { color: #ef4444; }

        .history-footer {
            padding: 15px 20px;
            border-top: 1px solid rgba(59,130,246,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .replay-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: linear-gradient(135deg, rgba(59,130,246,0.2), rgba(6,182,212,0.15));
            border: 1px solid rgba(59,130,246,0.4);
            color: var(--primary-blue);
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .replay-btn:hover { background: linear-gradient(135deg, rgba(59,130,246,0.3), rgba(6,182,212,0.25)); }
        .footer-info {
            font-size: 0.55rem;
            color: rgba(248,250,252,0.4);
            text-align: right;
        }
    </style>
    <link rel="stylesheet" href="membership-gating.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <a href="index.html" class="back-btn">Back to Overview</a>
            <h1 class="title">FINANCIAL GALAXY</h1>
        </div>
        <div style="font-size: 0.6rem; color: rgba(248,250,252,0.5);">Economic Weather meets Space Map</div>
    </header>

    <!-- Controls Panel -->
    <div class="controls-panel" id="controlsPanel">
        <div class="controls-title">Layer Controls</div>
        <div class="layer-toggle" data-layer="payments">
            <label>Payments</label>
            <div class="toggle-switch active" id="togglePayments"></div>
        </div>
        <div class="layer-toggle" data-layer="taxes">
            <label>Taxes</label>
            <div class="toggle-switch active" id="toggleTaxes"></div>
        </div>
        <div class="layer-toggle" data-layer="bankfees">
            <label>Bank Fees</label>
            <div class="toggle-switch active" id="toggleBankFees"></div>
        </div>
        <div class="layer-toggle" data-layer="crypto">
            <label>Crypto Flows</label>
            <div class="toggle-switch active" id="toggleCrypto"></div>
        </div>
        <div class="layer-toggle" data-layer="news">
            <label>News Impulse</label>
            <div class="toggle-switch" id="toggleNews"></div>
        </div>
        <div class="speed-control">
            <label>Speed: <span id="speedValue">1.0x</span></label>
            <input type="range" class="speed-slider" id="speedSlider" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div class="control-buttons">
            <button class="ctrl-btn" id="pauseBtn">PAUSE</button>
            <button class="ctrl-btn" id="focusBtn">FOCUS</button>
        </div>
    </div>

    <!-- Mobile Toggle -->
    <button class="mobile-toggle-btn" id="mobileToggle">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="4" y1="6" x2="20" y2="6"></line>
            <line x1="4" y1="12" x2="20" y2="12"></line>
            <line x1="4" y1="18" x2="20" y2="18"></line>
        </svg>
    </button>

    <!-- Galaxy Canvas -->
    <canvas id="galaxy-canvas"></canvas>

    <!-- Hover Panel -->
    <div class="hover-panel" id="hoverPanel">
        <div class="panel-header" id="panelHeader">
            <div class="panel-header-left">
                <span class="panel-icon" id="panelIcon"></span>
                <span class="panel-title" id="panelTitle">Element</span>
            </div>
            <span class="status-badge status-live" id="panelStatus">LIVE</span>
        </div>
        <div class="panel-body">
            <p class="panel-description" id="panelDescription">Element description...</p>
            <div class="panel-stats" id="panelStats"></div>
            <div class="sparkline-container" id="sparklineContainer">
                <div class="sparkline-label">24h History</div>
                <div class="sparkline">
                    <svg width="100%" height="100%" id="sparklineSvg">
                        <defs>
                            <linearGradient id="sparkGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:0.3"/>
                                <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:0"/>
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
            </div>
            <div class="causality-box" id="causalityBox">
                <div class="causality-title">Cause - Effect</div>
                <div class="causality-flow" id="causalityFlow"></div>
            </div>
        </div>
        <div class="panel-footer">
            <span id="panelTimestamp">--:--:--</span>
            <span id="panelSource">Source: --</span>
        </div>
    </div>

    <!-- Footer Claim -->
    <div class="footer-claim">
        <p class="claim-text">"Attention moves capital. Rules direct it. Friction consumes it. Transparency decides."</p>
    </div>

    <!-- Market Signals History Tab -->
    <div class="history-tab" id="historyTab" onclick="toggleHistoryPanel()">
        ‚ö° MARKET SIGNALS
    </div>

    <!-- Market Signals History Panel -->
    <div class="history-panel" id="historyPanel">
        <div class="history-header">
            <span class="history-title">üåê Market Signals ¬∑ Financial Galaxy</span>
            <button class="history-close" onclick="toggleHistoryPanel()">√ó</button>
        </div>
        <div class="history-filters">
            <button class="filter-btn active" data-range="7" onclick="filterHistory(7)">7D</button>
            <button class="filter-btn" data-range="30" onclick="filterHistory(30)">1M</button>
            <button class="filter-btn" data-range="90" onclick="filterHistory(90)">3M</button>
            <button class="filter-btn" data-range="180" onclick="filterHistory(180)">6M</button>
            <button class="filter-btn" data-range="365" onclick="filterHistory(365)">12M</button>
        </div>
        <div class="history-timeline">
            <div class="timeline-bar" id="timelineBar"></div>
        </div>
        <div class="history-content" id="historyContent"></div>
        <div class="history-footer">
            <button class="replay-btn" onclick="replayMarketSignals()">
                <span>‚ñ∂</span> Replay Signals
            </button>
            <div class="footer-info">
                <div>Macro Data ¬∑ Simulated</div>
                <div>Educational visualization only</div>
            </div>
        </div>
    </div>

    <script>
    // ========== FINANCIAL GALAXY ENGINE ==========
    const canvas = document.getElementById('galaxy-canvas');
    const ctx = canvas.getContext('2d');
    let width, height, centerX, centerY;
    let animationSpeed = 1;
    let isPaused = false;
    let focusMode = false;
    let focusedActor = null;
    let hoveredActor = null;
    let mouseX = 0, mouseY = 0;

    // Layers
    const layers = {
        payments: true,
        taxes: true,
        bankfees: true,
        crypto: true,
        news: false
    };

    // Crypto Data Cache
    let cryptoData = {};
    let lastCryptoUpdate = 0;

    // Actors Definition
    const actors = {
        state: {
            name: 'STATE',
            icon: 'O',
            color: '#f59e0b',
            glowColor: 'rgba(245, 158, 11, 0.4)',
            x: 0, y: 0,
            radius: 80,
            description: 'Central gravity point of the financial system. Attracts tax revenues and regulates money flows.',
            status: 'SIMULATED',
            stats: { taxRevenue: '~850B EUR/Year', stateQuota: '~45%', debt: '~2.4T EUR' },
            causality: ['Tax Obligation', 'Collection', 'State Budget'],
            source: 'Federal Ministry of Finance (sim.)'
        },
        banks: {
            name: 'BANKS',
            icon: 'B',
            color: '#6b7280',
            glowColor: 'rgba(107, 114, 128, 0.3)',
            orbitRadius: 200,
            orbitSpeed: 0.0003,
            angle: 0,
            x: 0, y: 0,
            radius: 40,
            count: 4,
            description: 'Orbital nodes in the system. Route money flows and extract fees as "Energy Loss".',
            status: 'SIMULATED',
            stats: { transactions: '~500M/Day', fees: '~0.1-3%', latency: '1-3 Days' },
            causality: ['Transfer', 'Settlement', 'Fee'],
            source: 'Banking Statistics (sim.)'
        },
        exchanges: {
            name: 'EXCHANGES',
            icon: 'X',
            color: '#8b5cf6',
            glowColor: 'rgba(139, 92, 246, 0.5)',
            orbitRadius: 320,
            orbitSpeed: 0.0005,
            angle: Math.PI,
            x: 0, y: 0,
            radius: 35,
            count: 3,
            description: 'Portals between Fiat and Crypto. Convert currencies with instant settlement.',
            status: 'LIVE',
            stats: { volume24h: '$0', spread: '0.1-0.5%', pairs: '500+' },
            causality: ['Fiat Deposit', 'Conversion', 'Crypto'],
            source: 'CoinGecko API'
        },
        crypto: {
            name: 'CRYPTO',
            icon: 'C',
            color: '#06b6d4',
            glowColor: 'rgba(6, 182, 212, 0.5)',
            particles: [],
            description: 'Moving particles in the system. React to market sentiment and news signals.',
            status: 'LIVE',
            stats: { btcPrice: '$0', ethPrice: '$0', dominance: '0%' },
            causality: ['Signal', 'Reaction', 'Price Movement'],
            source: 'CoinGecko API'
        },
        customers: {
            name: 'CUSTOMERS',
            icon: 'K',
            color: '#10b981',
            glowColor: 'rgba(16, 185, 129, 0.3)',
            clouds: [],
            emotion: 'neutral',
            description: 'Dynamic particle clouds. Emotions: Fear (red), Greed (green), Panic (fast/red).',
            status: 'SIMULATED',
            stats: { sentiment: 'Neutral', activity: 'Medium', volume: '~$50B/Day' },
            causality: ['Emotion', 'Decision', 'Transaction'],
            source: 'Market Analysis (sim.)'
        }
    };

    // Flow Particles
    let flowParticles = [];
    let newsRipples = [];

    // Initialize
    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('click', onClick);
        canvas.addEventListener('touchstart', onTouch);
        initCryptoParticles();
        initCustomerClouds();
        fetchCryptoData();
        setInterval(fetchCryptoData, 30000);
        setupControls();
        animate();
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        centerX = width / 2;
        centerY = height / 2;
        actors.state.x = centerX;
        actors.state.y = centerY;
    }

    function initCryptoParticles() {
        actors.crypto.particles = [];
        for (let i = 0; i < 50; i++) {
            actors.crypto.particles.push({
                x: centerX + (Math.random() - 0.5) * 600,
                y: centerY + (Math.random() - 0.5) * 400,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                size: 2 + Math.random() * 4,
                brightness: 0.5 + Math.random() * 0.5
            });
        }
    }

    function initCustomerClouds() {
        actors.customers.clouds = [];
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 350 + Math.random() * 150;
            actors.customers.clouds.push({
                x: centerX + Math.cos(angle) * dist,
                y: centerY + Math.sin(angle) * dist,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: 3 + Math.random() * 5,
                emotion: Math.random()
            });
        }
    }

    // Fetch Crypto Data from CoinGecko
    async function fetchCryptoData() {
        try {
            const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true&include_market_cap=true');
            const data = await response.json();
            cryptoData = data;
            lastCryptoUpdate = Date.now();
            updateActorStats();
        } catch (e) {
            console.log('CoinGecko API error, using simulated data');
        }
    }

    function updateActorStats() {
        if (cryptoData.bitcoin) {
            actors.crypto.stats.btcPrice = '$' + cryptoData.bitcoin.usd.toLocaleString();
            actors.crypto.stats.ethPrice = '$' + (cryptoData.ethereum?.usd || 0).toLocaleString();
            const vol = (cryptoData.bitcoin.usd_24h_vol || 0) / 1e9;
            actors.exchanges.stats.volume24h = '$' + vol.toFixed(1) + 'B';
        }
    }

    // Animation Loop
    function animate(timestamp) {
        if (!isPaused) {
            update(timestamp);
        }
        draw();
        requestAnimationFrame(animate);
    }

    function update(timestamp) {
        const dt = animationSpeed;
        
        // Update Bank Orbits
        for (let i = 0; i < actors.banks.count; i++) {
            const baseAngle = (i / actors.banks.count) * Math.PI * 2;
            actors.banks.angle += actors.banks.orbitSpeed * dt;
        }
        
        // Update Exchange Orbits
        actors.exchanges.angle += actors.exchanges.orbitSpeed * dt;
        
        // Update Crypto Particles
        if (layers.crypto) {
            actors.crypto.particles.forEach(p => {
                // Attraction to center
                const dx = centerX - p.x;
                const dy = centerY - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 50) {
                    p.vx += (dx / dist) * 0.01 * dt;
                    p.vy += (dy / dist) * 0.01 * dt;
                }
                p.vx *= 0.99;
                p.vy *= 0.99;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                
                // Bounds
                if (p.x < 50 || p.x > width - 50) p.vx *= -1;
                if (p.y < 50 || p.y > height - 50) p.vy *= -1;
            });
        }
        
        // Update Customer Clouds
        actors.customers.clouds.forEach(c => {
            c.x += c.vx * dt;
            c.y += c.vy * dt;
            const dx = centerX - c.x;
            const dy = centerY - c.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 300 || dist > 550) {
                c.vx += (dx / dist) * 0.02 * dt * (dist < 300 ? -1 : 1);
                c.vy += (dy / dist) * 0.02 * dt * (dist < 300 ? -1 : 1);
            }
            c.vx *= 0.98;
            c.vy *= 0.98;
        });
        
        // Update Flow Particles
        updateFlowParticles(dt);
        
        // Generate new flows
        if (Math.random() < 0.02 * dt && layers.payments) spawnPaymentFlow();
        if (Math.random() < 0.01 * dt && layers.taxes) spawnTaxFlow();
        if (Math.random() < 0.015 * dt && layers.bankfees) spawnFeeParticle();
        
        // Update News Ripples
        if (layers.news) {
            newsRipples = newsRipples.filter(r => r.radius < 600);
            newsRipples.forEach(r => {
                r.radius += 3 * dt;
                r.opacity -= 0.005 * dt;
            });
            if (Math.random() < 0.002 * dt) {
                newsRipples.push({ x: centerX + (Math.random()-0.5)*400, y: centerY + (Math.random()-0.5)*300, radius: 10, opacity: 0.6 });
            }
        }
    }

    function spawnPaymentFlow() {
        const startAngle = Math.random() * Math.PI * 2;
        const startDist = 400 + Math.random() * 100;
        flowParticles.push({
            type: 'payment',
            x: centerX + Math.cos(startAngle) * startDist,
            y: centerY + Math.sin(startAngle) * startDist,
            targetX: centerX + (Math.random()-0.5) * 100,
            targetY: centerY + (Math.random()-0.5) * 100,
            progress: 0,
            speed: 0.005 + Math.random() * 0.005,
            color: '#22d3ee',
            size: 3
        });
    }

    function spawnTaxFlow() {
        const bankIndex = Math.floor(Math.random() * actors.banks.count);
        const bankAngle = actors.banks.angle + (bankIndex / actors.banks.count) * Math.PI * 2;
        const bankX = centerX + Math.cos(bankAngle) * actors.banks.orbitRadius;
        const bankY = centerY + Math.sin(bankAngle) * actors.banks.orbitRadius;
        flowParticles.push({
            type: 'tax',
            x: bankX,
            y: bankY,
            targetX: centerX,
            targetY: centerY,
            progress: 0,
            speed: 0.008,
            color: '#ef4444',
            size: 4
        });
    }

    function spawnFeeParticle() {
        const bankIndex = Math.floor(Math.random() * actors.banks.count);
        const bankAngle = actors.banks.angle + (bankIndex / actors.banks.count) * Math.PI * 2;
        const bankX = centerX + Math.cos(bankAngle) * actors.banks.orbitRadius;
        const bankY = centerY + Math.sin(bankAngle) * actors.banks.orbitRadius;
        flowParticles.push({
            type: 'fee',
            x: bankX,
            y: bankY,
            vx: (Math.random() - 0.5) * 3,
            vy: -2 - Math.random() * 2,
            life: 1,
            color: '#fbbf24',
            size: 2
        });
    }

    function updateFlowParticles(dt) {
        flowParticles = flowParticles.filter(p => {
            if (p.type === 'fee') {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 0.05 * dt;
                p.life -= 0.02 * dt;
                p.size *= 0.98;
                return p.life > 0 && p.size > 0.5;
            } else {
                p.progress += p.speed * dt;
                if (p.progress >= 1) {
                    if (p.type === 'payment') createSettlementFlash(p.targetX, p.targetY);
                    return false;
                }
                return true;
            }
        });
    }

    function createSettlementFlash(x, y) {
        // Flash effect handled in draw
    }

    // Drawing
    function draw() {
        ctx.fillStyle = 'rgba(5, 8, 16, 0.15)';
        ctx.fillRect(0, 0, width, height);
        
        drawStars();
        drawGravityField();
        if (layers.taxes) drawTaxStreams();
        drawState();
        drawBanks();
        drawExchanges();
        if (layers.crypto) drawCryptoParticles();
        drawCustomerClouds();
        drawFlowParticles();
        if (layers.news) drawNewsRipples();
        
        if (focusMode && focusedActor) drawFocusZoom();
    }

    function drawStars() {
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        for (let i = 0; i < 100; i++) {
            const x = (i * 137.5) % width;
            const y = (i * 97.3) % height;
            ctx.beginPath();
            ctx.arc(x, y, 0.5 + Math.random() * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawGravityField() {
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 400);
        gradient.addColorStop(0, 'rgba(245, 158, 11, 0.1)');
        gradient.addColorStop(0.5, 'rgba(245, 158, 11, 0.03)');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
    }

    function drawTaxStreams() {
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.2)';
        ctx.lineWidth = 2;
        for (let i = 0; i < actors.banks.count; i++) {
            const angle = actors.banks.angle + (i / actors.banks.count) * Math.PI * 2;
            const bx = centerX + Math.cos(angle) * actors.banks.orbitRadius;
            const by = centerY + Math.sin(angle) * actors.banks.orbitRadius;
            ctx.beginPath();
            ctx.moveTo(bx, by);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
        }
    }

    function drawState() {
        const a = actors.state;
        const isHovered = hoveredActor === 'state';
        const hoverScale = isHovered ? 1.15 : 1;
        const effectiveRadius = a.radius * hoverScale;
        
        // Hover highlight ring
        if (isHovered) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(a.x, a.y, effectiveRadius + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = a.color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(a.x, a.y, effectiveRadius + 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Glow
        const glow = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, effectiveRadius * 2);
        glow.addColorStop(0, isHovered ? 'rgba(245, 158, 11, 0.6)' : a.glowColor);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fillRect(a.x - effectiveRadius * 2, a.y - effectiveRadius * 2, effectiveRadius * 4, effectiveRadius * 4);
        
        // Planet
        const planetGrad = ctx.createRadialGradient(a.x - 20, a.y - 20, 0, a.x, a.y, effectiveRadius);
        planetGrad.addColorStop(0, '#fcd34d');
        planetGrad.addColorStop(0.7, a.color);
        planetGrad.addColorStop(1, '#b45309');
        ctx.fillStyle = planetGrad;
        ctx.beginPath();
        ctx.arc(a.x, a.y, effectiveRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Label
        ctx.fillStyle = '#1a1a2e';
        ctx.font = 'bold 14px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('STATE', a.x, a.y + 5);
        
        a.screenBounds = { x: a.x - a.radius, y: a.y - a.radius, w: a.radius * 2, h: a.radius * 2 };
    }

    function drawBanks() {
        const isHovered = hoveredActor === 'banks';
        for (let i = 0; i < actors.banks.count; i++) {
            const angle = actors.banks.angle + (i / actors.banks.count) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * actors.banks.orbitRadius;
            const y = centerY + Math.sin(angle) * actors.banks.orbitRadius;
            const radius = isHovered ? actors.banks.radius * 1.2 : actors.banks.radius;
            
            // Hover highlight
            if (isHovered) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Glow
            ctx.shadowColor = isHovered ? 'rgba(107, 114, 128, 0.8)' : actors.banks.glowColor;
            ctx.shadowBlur = isHovered ? 35 : 20;
            
            // Node
            ctx.fillStyle = isHovered ? '#9ca3af' : actors.banks.color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Icon
            ctx.fillStyle = '#d1d5db';
            ctx.font = 'bold 12px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('BANK', x, y + 4);
        }
        actors.banks.screenBounds = { x: centerX - actors.banks.orbitRadius - 50, y: centerY - actors.banks.orbitRadius - 50, w: (actors.banks.orbitRadius + 50) * 2, h: (actors.banks.orbitRadius + 50) * 2 };
    }

    function drawExchanges() {
        for (let i = 0; i < actors.exchanges.count; i++) {
            const angle = actors.exchanges.angle + (i / actors.exchanges.count) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * actors.exchanges.orbitRadius;
            const y = centerY + Math.sin(angle) * actors.exchanges.orbitRadius;
            
            // Portal effect
            ctx.save();
            ctx.translate(x, y);
            
            // Wormhole rings
            for (let r = 0; r < 3; r++) {
                const ringRadius = actors.exchanges.radius + r * 8;
                ctx.strokeStyle = `rgba(139, 92, 246, ${0.5 - r * 0.15})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Core
            const portalGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, actors.exchanges.radius);
            portalGrad.addColorStop(0, '#c4b5fd');
            portalGrad.addColorStop(0.5, actors.exchanges.color);
            portalGrad.addColorStop(1, '#4c1d95');
            ctx.fillStyle = portalGrad;
            ctx.beginPath();
            ctx.arc(0, 0, actors.exchanges.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('CEX', 0, 4);
            
            ctx.restore();
        }
    }

    function drawCryptoParticles() {
        actors.crypto.particles.forEach(p => {
            ctx.fillStyle = `rgba(6, 182, 212, ${p.brightness})`;
            ctx.shadowColor = actors.crypto.glowColor;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.shadowBlur = 0;
    }

    function drawCustomerClouds() {
        actors.customers.clouds.forEach(c => {
            const emotionColor = c.emotion < 0.3 ? 'rgba(239,68,68,' : c.emotion > 0.7 ? 'rgba(16,185,129,' : 'rgba(156,163,175,';
            ctx.fillStyle = emotionColor + '0.6)';
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawFlowParticles() {
        flowParticles.forEach(p => {
            if (p.type === 'fee') {
                ctx.fillStyle = `rgba(251, 191, 36, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            } else {
                const x = p.x + (p.targetX - p.x) * p.progress;
                const y = p.y + (p.targetY - p.y) * p.progress;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(x, y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        });
    }

    function drawNewsRipples() {
        newsRipples.forEach(r => {
            ctx.strokeStyle = `rgba(251, 191, 36, ${r.opacity})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
            ctx.stroke();
        });
    }

    function drawFocusZoom() {
        // Vignette
        const vignette = ctx.createRadialGradient(centerX, centerY, 100, centerX, centerY, Math.max(width, height) / 2);
        vignette.addColorStop(0, 'transparent');
        vignette.addColorStop(1, 'rgba(0,0,0,0.7)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, width, height);
    }

    // Interaction
    function onMouseMove(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        checkHover();
    }

    function onTouch(e) {
        if (e.touches.length > 0) {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
            checkHover();
        }
    }

    function onClick(e) {
        if (hoveredActor) {
            if (focusMode && focusedActor === hoveredActor) {
                focusMode = false;
                focusedActor = null;
            } else {
                focusMode = true;
                focusedActor = hoveredActor;
            }
        }
    }

    function checkHover() {
        const panel = document.getElementById('hoverPanel');
        let found = null;
        
        // Check State
        const stateDist = Math.sqrt((mouseX - actors.state.x)**2 + (mouseY - actors.state.y)**2);
        if (stateDist < actors.state.radius) found = 'state';
        
        // Check Banks
        if (!found) {
            for (let i = 0; i < actors.banks.count; i++) {
                const angle = actors.banks.angle + (i / actors.banks.count) * Math.PI * 2;
                const bx = centerX + Math.cos(angle) * actors.banks.orbitRadius;
                const by = centerY + Math.sin(angle) * actors.banks.orbitRadius;
                const dist = Math.sqrt((mouseX - bx)**2 + (mouseY - by)**2);
                if (dist < actors.banks.radius) { found = 'banks'; break; }
            }
        }
        
        // Check Exchanges
        if (!found) {
            for (let i = 0; i < actors.exchanges.count; i++) {
                const angle = actors.exchanges.angle + (i / actors.exchanges.count) * Math.PI * 2;
                const ex = centerX + Math.cos(angle) * actors.exchanges.orbitRadius;
                const ey = centerY + Math.sin(angle) * actors.exchanges.orbitRadius;
                const dist = Math.sqrt((mouseX - ex)**2 + (mouseY - ey)**2);
                if (dist < actors.exchanges.radius + 20) { found = 'exchanges'; break; }
            }
        }
        
        // Check Crypto cloud
        if (!found) {
            for (const p of actors.crypto.particles) {
                const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                if (dist < 30) { found = 'crypto'; break; }
            }
        }
        
        // Check Customers
        if (!found) {
            for (const c of actors.customers.clouds) {
                const dist = Math.sqrt((mouseX - c.x)**2 + (mouseY - c.y)**2);
                if (dist < 20) { found = 'customers'; break; }
            }
        }
        
        if (found && found !== hoveredActor) {
            hoveredActor = found;
            showPanel(found);
        } else if (!found && hoveredActor) {
            hoveredActor = null;
            panel.classList.remove('visible');
        }
    }

    function showPanel(actorKey) {
        const actor = actors[actorKey];
        const panel = document.getElementById('hoverPanel');
        
        document.getElementById('panelIcon').textContent = actorKey === 'state' ? '0' : actorKey === 'banks' ? 'B' : actorKey === 'exchanges' ? 'X' : actorKey === 'crypto' ? 'C' : 'K';
        document.getElementById('panelTitle').textContent = actor.name;
        document.getElementById('panelDescription').textContent = actor.description;
        
        const statusEl = document.getElementById('panelStatus');
        statusEl.textContent = actor.status;
        statusEl.className = 'status-badge status-' + actor.status.toLowerCase();
        
        // Stats
        const statsEl = document.getElementById('panelStats');
        statsEl.innerHTML = '';
        for (const [key, value] of Object.entries(actor.stats)) {
            const change = Math.random() > 0.5;
            const changeVal = (Math.random() * 5).toFixed(2);
            statsEl.innerHTML += `
                <div class="stat-item">
                    <div class="stat-label">${key.replace(/([A-Z])/g, ' $1').trim()}</div>
                    <div class="stat-value">${value}</div>
                    <div class="stat-change ${change ? 'positive' : 'negative'}">${change ? '+' : '-'}${changeVal}%</div>
                </div>
            `;
        }
        
        // Sparkline
        drawSparkline();
        
        // Causality
        const causalityEl = document.getElementById('causalityFlow');
        causalityEl.innerHTML = actor.causality.map((item, i) => 
            `<span class="causality-item">${item}</span>${i < actor.causality.length - 1 ? '<span class="causality-arrow">-></span>' : ''}`
        ).join('');
        
        // Footer
        document.getElementById('panelTimestamp').textContent = new Date().toLocaleTimeString('en-US');
        document.getElementById('panelSource').textContent = 'Source: ' + actor.source;
        
        // Position panel
        let panelX = mouseX + 20;
        let panelY = mouseY - 100;
        if (panelX + 400 > width) panelX = mouseX - 420;
        if (panelY < 80) panelY = 80;
        if (panelY + 400 > height) panelY = height - 420;
        
        if (window.innerWidth > 768) {
            panel.style.left = panelX + 'px';
            panel.style.top = panelY + 'px';
        }
        
        panel.style.borderColor = actor.color;
        document.getElementById('panelHeader').style.background = `linear-gradient(135deg, ${actor.color}22, ${actor.color}11)`;
        
        panel.classList.add('visible');
    }

    function drawSparkline() {
        const svg = document.getElementById('sparklineSvg');
        const rect = svg.getBoundingClientRect();
        const w = rect.width || 280;
        const h = 40;
        
        // Generate random sparkline data
        const points = [];
        for (let i = 0; i < 20; i++) {
            points.push(10 + Math.random() * 20);
        }
        
        const maxY = Math.max(...points);
        const minY = Math.min(...points);
        const scaleX = w / (points.length - 1);
        const scaleY = (h - 10) / (maxY - minY || 1);
        
        let pathD = '';
        let areaD = `M 0 ${h}`;
        
        points.forEach((p, i) => {
            const x = i * scaleX;
            const y = h - 5 - (p - minY) * scaleY;
            if (i === 0) {
                pathD = `M ${x} ${y}`;
                areaD += ` L ${x} ${y}`;
            } else {
                pathD += ` L ${x} ${y}`;
                areaD += ` L ${x} ${y}`;
            }
        });
        areaD += ` L ${w} ${h} Z`;
        
        svg.innerHTML = `
            <defs>
                <linearGradient id="sparkGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:0.3"/>
                    <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:0"/>
                </linearGradient>
            </defs>
            <path d="${areaD}" fill="url(#sparkGradient)"/>
            <path d="${pathD}" stroke="#3b82f6" stroke-width="2" fill="none"/>
        `;
    }

    // Controls
    function setupControls() {
        // Layer toggles with visual feedback
        document.querySelectorAll('.layer-toggle').forEach(el => {
            const layer = el.dataset.layer;
            const toggle = el.querySelector('.toggle-switch');
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                layers[layer] = !layers[layer];
                toggle.classList.toggle('active', layers[layer]);
                // Visual feedback
                el.style.transform = 'scale(0.95)';
                setTimeout(() => el.style.transform = 'scale(1)', 100);
                console.log('Layer toggled:', layer, layers[layer]);
            });
            // Initialize state
            toggle.classList.toggle('active', layers[layer]);
        });
        
        // Speed slider
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        speedSlider.addEventListener('input', () => {
            animationSpeed = parseFloat(speedSlider.value);
            speedValue.textContent = animationSpeed.toFixed(1) + 'x';
        });
        
        // Pause button
        document.getElementById('pauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'RESUME' : 'PAUSE';
            this.classList.toggle('active', isPaused);
        });
        
        // Focus button
        document.getElementById('focusBtn').addEventListener('click', function() {
            focusMode = !focusMode;
            this.classList.toggle('active', focusMode);
            if (!focusMode) focusedActor = null;
        });
        
        // Mobile toggle
        document.getElementById('mobileToggle').addEventListener('click', () => {
            document.getElementById('controlsPanel').classList.toggle('visible');
        });
    }

    // Initialize
    init();

    // ========== MARKET SIGNALS HISTORY PANEL ==========
    let historyPanelOpen = false;
    let currentHistoryRange = 7;
    let marketSignalEvents = [];
    let historyAutoHideTimer = null;

    function toggleHistoryPanel() {
        historyPanelOpen = !historyPanelOpen;
        const panel = document.getElementById('historyPanel');
        const tab = document.getElementById('historyTab');
        panel.classList.toggle('open', historyPanelOpen);
        tab.classList.toggle('hidden', historyPanelOpen);
        if (historyPanelOpen) {
            generateMarketSignalEvents();
            renderHistoryPanel();
            startAutoHideTimer();
        } else {
            clearAutoHideTimer();
        }
    }

    function startAutoHideTimer() {
        clearAutoHideTimer();
        historyAutoHideTimer = setTimeout(() => {
            if (historyPanelOpen) toggleHistoryPanel();
        }, 45000);
    }

    function clearAutoHideTimer() {
        if (historyAutoHideTimer) {
            clearTimeout(historyAutoHideTimer);
            historyAutoHideTimer = null;
        }
    }

    document.getElementById('historyPanel').addEventListener('mouseenter', clearAutoHideTimer);
    document.getElementById('historyPanel').addEventListener('mouseleave', () => {
        if (historyPanelOpen) startAutoHideTimer();
    });

    function filterHistory(days) {
        currentHistoryRange = days;
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.range) === days);
        });
        generateMarketSignalEvents();
        renderHistoryPanel();
    }

    const signalCategories = [
        { type: 'central-bank', name: 'Central Bank', icon: 'üè¶', examples: ['FED Rate Decision', 'ECB Policy Meeting', 'BOJ Intervention', 'PBOC Liquidity Injection'] },
        { type: 'macro-data', name: 'Macro Data', icon: 'üìä', examples: ['US CPI Release', 'NFP Report', 'GDP Growth Data', 'PMI Manufacturing'] },
        { type: 'institutional', name: 'Institutional', icon: 'üíº', examples: ['BlackRock BTC ETF Flow', 'Grayscale Outflow', 'MicroStrategy Purchase', 'Pension Fund Allocation'] },
        { type: 'geopolitical', name: 'Geopolitical', icon: 'üåç', examples: ['US-China Tensions', 'OPEC Decision', 'EU Regulation', 'Trade Agreement'] }
    ];

    const assetClasses = ['Crypto', 'Equities', 'FX', 'Commodities', 'Bonds'];

    function generateMarketSignalEvents() {
        marketSignalEvents = [];
        const eventCount = Math.floor(currentHistoryRange / 2) + 5;
        
        for (let i = 0; i < eventCount; i++) {
            const category = signalCategories[Math.floor(Math.random() * signalCategories.length)];
            const daysAgo = Math.floor(Math.random() * currentHistoryRange);
            const date = new Date();
            date.setDate(date.getDate() - daysAgo);
            
            const affectedAssets = [];
            const numAssets = 1 + Math.floor(Math.random() * 3);
            const shuffled = [...assetClasses].sort(() => Math.random() - 0.5);
            for (let j = 0; j < numAssets; j++) affectedAssets.push(shuffled[j]);
            
            const impact = (Math.random() - 0.4) * 10;
            const volatility = 5 + Math.random() * 25;
            const duration = Math.floor(1 + Math.random() * 48);
            
            marketSignalEvents.push({
                category: category.type,
                categoryName: category.name,
                icon: category.icon,
                title: category.examples[Math.floor(Math.random() * category.examples.length)],
                affectedAssets,
                impact: impact.toFixed(2),
                volatility: volatility.toFixed(1),
                duration: duration + 'h',
                date,
                daysAgo
            });
        }
        marketSignalEvents.sort((a, b) => a.daysAgo - b.daysAgo);
    }

    function renderHistoryPanel() {
        renderTimeline();
        renderEventList();
    }

    function renderTimeline() {
        const bar = document.getElementById('timelineBar');
        bar.innerHTML = '';
        marketSignalEvents.forEach((event, idx) => {
            const pos = (1 - event.daysAgo / currentHistoryRange) * 100;
            const marker = document.createElement('div');
            marker.className = `timeline-marker ${event.category}`;
            marker.style.left = `calc(${pos}% - 4px)`;
            marker.title = `${event.title} (${event.daysAgo}d ago)`;
            marker.onclick = () => highlightEvent(idx);
            bar.appendChild(marker);
        });
    }

    function renderEventList() {
        const container = document.getElementById('historyContent');
        container.innerHTML = marketSignalEvents.map((event, idx) => `
            <div class="signal-event" data-idx="${idx}" onclick="highlightEvent(${idx})">
                <div class="event-header">
                    <div class="event-source">
                        <span class="source-badge ${event.category}">${event.icon} ${event.categoryName}</span>
                    </div>
                    <span class="event-time">${event.daysAgo === 0 ? 'Today' : event.daysAgo + 'd ago'}</span>
                </div>
                <div class="event-title">${event.title}</div>
                <div class="event-impact">
                    ${event.affectedAssets.map(a => `<span class="impact-tag">${a}</span>`).join('')}
                </div>
                <div class="event-stats">
                    <div class="stat-mini">
                        <div class="stat-mini-label">Impact</div>
                        <div class="stat-mini-value ${parseFloat(event.impact) >= 0 ? 'positive' : 'negative'}">${parseFloat(event.impact) >= 0 ? '+' : ''}${event.impact}%</div>
                    </div>
                    <div class="stat-mini">
                        <div class="stat-mini-label">Volatility</div>
                        <div class="stat-mini-value">${event.volatility}%</div>
                    </div>
                    <div class="stat-mini">
                        <div class="stat-mini-label">Duration</div>
                        <div class="stat-mini-value">${event.duration}</div>
                    </div>
                </div>
            </div>
        `).join('');
    }

    function highlightEvent(idx) {
        document.querySelectorAll('.signal-event').forEach(el => el.classList.remove('highlighted'));
        const eventEl = document.querySelector(`.signal-event[data-idx="${idx}"]`);
        if (eventEl) {
            eventEl.classList.add('highlighted');
            eventEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        const event = marketSignalEvents[idx];
        highlightGalaxyAssets(event.affectedAssets, event.impact);
    }

    function highlightGalaxyAssets(assets, impact) {
        // Create visual pulse effect on canvas actors
        const impactColor = parseFloat(impact) >= 0 ? 'rgba(16,185,129,0.6)' : 'rgba(239,68,68,0.6)';
        
        // Trigger news ripples at actor positions
        if (assets.includes('Crypto')) {
            actors.crypto.particles.forEach(p => {
                p.vx += (Math.random() - 0.5) * 3;
                p.vy += (Math.random() - 0.5) * 3;
            });
            newsRipples.push({ x: centerX, y: centerY, radius: 10, opacity: 0.8 });
        }
        if (assets.includes('FX') || assets.includes('Equities')) {
            for (let i = 0; i < actors.banks.count; i++) {
                const angle = actors.banks.angle + (i / actors.banks.count) * Math.PI * 2;
                const bx = centerX + Math.cos(angle) * actors.banks.orbitRadius;
                const by = centerY + Math.sin(angle) * actors.banks.orbitRadius;
                newsRipples.push({ x: bx, y: by, radius: 5, opacity: 0.7 });
            }
        }
        if (assets.includes('Commodities') || assets.includes('Bonds')) {
            newsRipples.push({ x: centerX, y: centerY - 100, radius: 15, opacity: 0.6 });
        }
        
        // Temporarily enable news layer for effect
        const wasNewsOn = layers.news;
        layers.news = true;
        setTimeout(() => { layers.news = wasNewsOn; }, 3000);
    }

    function replayMarketSignals() {
        if (marketSignalEvents.length === 0) return;
        let idx = 0;
        const replayInterval = setInterval(() => {
            if (idx >= marketSignalEvents.length) {
                clearInterval(replayInterval);
                return;
            }
            highlightEvent(idx);
            idx++;
        }, 1200);
    }
    </script>
    <script src="membership-gating.js"></script>
</body>
</html>
